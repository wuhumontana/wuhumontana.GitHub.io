<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuhumontana.github.io</id>
    <title>Kyle Wang</title>
    <updated>2023-12-28T05:06:52.658Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuhumontana.github.io"/>
    <link rel="self" href="https://wuhumontana.github.io/atom.xml"/>
    <subtitle>‰ø°‰∫éÂøÉÔºåÁÆÄ‰∫éË°å</subtitle>
    <logo>https://wuhumontana.github.io/images/avatar.png</logo>
    <icon>https://wuhumontana.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Kyle Wang</rights>
    <entry>
        <title type="html"><![CDATA[Spring CLI - Windows Scoop Installation]]></title>
        <id>https://wuhumontana.github.io/post/spring-cli-windows-scoop-installation/</id>
        <link href="https://wuhumontana.github.io/post/spring-cli-windows-scoop-installation/">
        </link>
        <updated>2023-08-16T15:10:14.000Z</updated>
        <content type="html"><![CDATA[<h3 id="introduction">üí°Introduction</h3>
<p>Scoop is a command-line installer for Windows. For actual users, it is very similar to the package management tool.</p>
<hr>
<h3 id="install-the-scoop">ü•ÑInstall the <strong>Scoop</strong></h3>
<p>Allowed execution of local scripts:</p>
<pre><code>Set-ExecutionPolicy RemoteSigned -Scope CurrentUser 
</code></pre>
<p>Install the Scoop</p>
<pre><code>irm get.scoop.sh | iex
</code></pre>
<p>Install aria2 for multi-thread download acceleration:</p>
<pre><code>scoop install aria2
</code></pre>
<p>Test whether the installation is successful:</p>
<pre><code>scoop help
</code></pre>
<hr>
<h3 id="install-the-spring-boot-cli">üå±Install  the  <strong>Spring Boot CLI</strong></h3>
<pre><code>scoop bucket add extras
scoop install springboot
</code></pre>
<hr>
<h3 id="common-command">üìùCommon Command</h3>
<table>
<thead>
<tr>
<th>Command</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>search</td>
<td>ÊêúÁ¥¢ËΩØ‰ª∂Âêç</td>
</tr>
<tr>
<td>install</td>
<td>ÂÆâË£ÖËΩØ‰ª∂</td>
</tr>
<tr>
<td>update</td>
<td>Êõ¥Êñ∞ËΩØ‰ª∂</td>
</tr>
<tr>
<td>status</td>
<td>Êü•ÁúãËΩØ‰ª∂Áä∂ÊÄÅ</td>
</tr>
<tr>
<td>uninstall</td>
<td>Âç∏ËΩΩËΩØ‰ª∂</td>
</tr>
<tr>
<td>info</td>
<td>Êü•ÁúãËΩØ‰ª∂ËØ¶ÊÉÖ</td>
</tr>
<tr>
<td>home</td>
<td>ÊâìÂºÄËΩØ‰ª∂‰∏ªÈ°µ</td>
</tr>
</tbody>
</table>
<p>Install the specified spring verison:</p>
<pre><code>scoop install springboot@2.5.6
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 60 | 84. Largest Rectangle in Histogram]]></title>
        <id>https://wuhumontana.github.io/post/day-60-or-84-largest-rectangle-in-histogram/</id>
        <link href="https://wuhumontana.github.io/post/day-60-or-84-largest-rectangle-in-histogram/">
        </link>
        <updated>2023-08-16T15:00:31.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132108800">Day 55 | 392. Is Subsequence | 115. Distinct Subsequences</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132114441">Day 56 | 583. Delete Operation for Two Strings | 72. Edit Distance</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132164712">Day 57 | 647. Palindromic Substrings | 516. Longest Palindromic Subsequence</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132192508">Day 58 | 739. Daily Temperatures | 496. Next Greater Element I</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132215296">Day 59 | 503. Next Greater Element II | 42. Trapping Rain Water</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#84-largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="84-largest-rectangle-in-histogram">84. Largest Rectangle in Histogram</h1>
<p><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        stack.push(0);

        int[] newHeights = new int[heights.length + 2];
        System.arraycopy(heights, 0, newHeights, 1, heights.length);

        int result = 0;
        for(int i = 1; i &lt; newHeights.length; i++){
            if(newHeights[i] &gt; newHeights[stack.peek()]){
                stack.push(i);
            }else if(newHeights[i] == newHeights[stack.peek()]){
                stack.pop();
                stack.push(i);
            }else{
                while(newHeights[i] &lt; newHeights[stack.peek()]){
                    int mid = stack.pop();
                    int left = stack.peek();
                    int right = i;
                    int w = right - left - 1;
                    int h = newHeights[mid];
                    result = Math.max(w * h, result);
                }
                stack.push(i);
            }
        }
        return result;
    }
}
</code></pre>
<ul>
<li>Compare to <code>739. Daily Temperatures</code> and <code>42. Trapping Rain Water</code> are finding the first bar that larger than the current bar. This question is to find the first bar smaller than the current one. So the order of the elements in the monotonic stack is from largest to smallest.</li>
<li>We must add the <code>0</code> at the beginning of the heights array. Cause if the array itself is in descending order like <code>[8,6,4,2]</code>,  after <code>8</code> is in the stack, <code>6</code> is compared to the <code>8</code>. We could get the <code>mid(8)</code>, <code>right(6)</code>, but won't be able to get the left bar. Cause after popping out the <code>8</code>, there is no element in the stack.</li>
<li>We must add the <code>0</code> at the end of the heights array. Cause if the array itself is in ascending order like <code>[2,4,6,8]</code> order, all the elements in the stack will be descending and won't be able to trigger the <code>case 3</code>.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 59 | 503. Next Greater Element II | 42. Trapping Rain Water]]></title>
        <id>https://wuhumontana.github.io/post/day-59-or-503-next-greater-element-ii-or-42-trapping-rain-water/</id>
        <link href="https://wuhumontana.github.io/post/day-59-or-503-next-greater-element-ii-or-42-trapping-rain-water/">
        </link>
        <updated>2023-08-16T15:00:09.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132108800">Day 55 | 392. Is Subsequence | 115. Distinct Subsequences</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132114441">Day 56 | 583. Delete Operation for Two Strings | 72. Edit Distance</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132164712">Day 57 | 647. Palindromic Substrings | 516. Longest Palindromic Subsequence</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132192508">Day 58 | 739. Daily Temperatures | 496. Next Greater Element I</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#503-next-greater-element-ii">503. Next Greater Element II</a></li>
<li><a href="#42-trapping-rain-water">42. Trapping Rain Water</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="503-next-greater-element-ii">503. Next Greater Element II</h1>
<p><a href="https://leetcode.com/problems/next-greater-element-ii/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.add(0);

        int[] res = new int[nums.length];
        Arrays.fill(res, -1);

        int len = nums.length;
        for(int i = 1; i &lt; len*2; i++){
            if(nums[i % len] &lt;= nums[stack.peek()])
                stack.add(i % len);
            else{
                while(!stack.isEmpty() &amp;&amp; nums[i % len] &gt; nums[stack.peek()]){
                    res[stack.peek()] = nums[i % len];
                    stack.pop();
                }
                stack.add(i % len);
            }
        }
        return res;
    }
}
</code></pre>
<ul>
<li>This question is similar like <code>739. Daily Temperatures</code>.</li>
<li>Traverse the nums <code>2</code> times.</li>
<li>In the for loop, always use <code>i % nums.length</code> to get the actual <code>i</code>.</li>
</ul>
<hr>
<h1 id="42-trapping-rain-water">42. Trapping Rain Water</h1>
<p><a href="https://leetcode.com/problems/trapping-rain-water/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int trap(int[] height) {
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        stack.push(0);

        int len = height.length;
        int sum = 0;
        for (int i = 1; i &lt; len; i++){
            if (height[i] &lt; height[stack.peek()]){
                stack.push(i);
            } else if (height[i] == height[stack.peek()]){
                stack.pop();
                stack.push(i);
            } else {
                while(!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]){
                    int mid = stack.pop();
                    if(!stack.isEmpty()){
                        int left = stack.peek();
                        int h = Math.min(height[left], height[i]) - height[mid];
                        int w = i - left - 1;
                        sum += h*w;
                    }
                }
                stack.push(i);
            }
        }
        return sum;
    }
}
</code></pre>
<ul>
<li>When the heights of adjacent bars are equal, the left bar can not trap the rainwater. We should pop the left bar's index and push the current bar's index. But if we don't pop the left bar's index, the result won't be affected.</li>
<li>When we calculate the volume of rain water, <code>width = right - left - 1</code></li>
<li>In the while loop, each loop is calculated by <code>row</code>.</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 58 | 739. Daily Temperatures | 496. Next Greater Element I]]></title>
        <id>https://wuhumontana.github.io/post/day-58-or-739-daily-temperatures-or-496-next-greater-element-i/</id>
        <link href="https://wuhumontana.github.io/post/day-58-or-739-daily-temperatures-or-496-next-greater-element-i/">
        </link>
        <updated>2023-08-16T14:59:46.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132108800">Day 55 | 392. Is Subsequence | 115. Distinct Subsequences</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132114441">Day 56 | 583. Delete Operation for Two Strings | 72. Edit Distance</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132164712">Day 57 | 647. Palindromic Substrings | 516. Longest Palindromic Subsequence</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#monotonic-stack">Monotonic Stack</a></li>
<li><a href="#739-daily-temperatures">739. Daily Temperatures</a></li>
<li><a href="#496-next-greater-element-i">496. Next Greater Element I</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="monotonic-stack">Monotonic Stack</h1>
<ul>
<li>In a one-dimensional array, find the first element on the right or left of an element that is larger or smaller than itself.</li>
<li>The time complexity is <code>O(n)</code>.</li>
<li>The monotonic stack only needs to hold the index of the element.</li>
<li>There are three main criteria for using the monotonic stack.
<ul>
<li>1„ÄÅThe current element <code>T[i]</code> is smaller than the stack top element <code>T[stack.top()]</code>.</li>
<li>2„ÄÅThe current element <code>T[i]</code> is the same as the stack top element <code>T[stack.top()]</code>.</li>
<li>3„ÄÅThe current element <code>T[i]</code> is larger than the stack top element <code>T[stack.top()]</code>.</li>
</ul>
</li>
<li>When the monotonic stack is <code>increasing</code> (from the top to the bottom of the stack), this question is to find the one on the right that is <code>bigger</code> than the current element.</li>
<li>When the monotonic stack is <code>decreasing</code> (from the bottom to the top of the stack), this question is to find the one on the right that is <code>smaller</code> than the current element.</li>
</ul>
<h1 id="739-daily-temperatures">739. Daily Temperatures</h1>
<p><a href="https://leetcode.com/problems/daily-temperatures/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int lens = temperatures.length;
        int[] res = new int[lens];
        Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();
        stack.push(0);
        for(int i = 1; i &lt; lens; i++){
            if(temperatures[i] &lt;= temperatures[stack.peek()]){
                stack.push(i);
            }else{
                while(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]){
                    res[stack.peek()] = i - stack.peek();
                    stack.pop();
                }
                stack.push(i);
            }
        }
        return res;
    }
}
</code></pre>
<ul>
<li>When the monotonic stack is <code>increasing</code> (from the top to the bottom of the stack), this question is to find the one on the right that is <code>bigger</code> than the current element.</li>
</ul>
<h1 id="496-next-greater-element-i">496. Next Greater Element I</h1>
<p><a href="https://leetcode.com/problems/next-greater-element-i/description/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        stack.push(0);

        int[] res = new int[nums1.length];
        Arrays.fill(res, -1);

        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();
        for(int i = 0; i &lt; nums1.length; i++)
            hashMap.put(nums1[i], i);

        for(int i = 1; i &lt; nums2.length; i++){
            if(nums2[i] &lt;= nums2[stack.peek()])
                stack.add(i);
            else {
                while(!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]){
                    if(hashMap.containsKey(nums2[stack.peek()])){
                        int index = hashMap.get(nums2[stack.peek()]);
                        res[index] = nums2[i];
                    }
                    stack.pop();
                }
                stack.add(i);
            }
        }
        return res;
    }
}
</code></pre>
<ul>
<li>This question is similar like the <code>739. Daily Temperatures</code>. Keep the elements of the stack in increasing order(from the top to the bottom of the stack), then we can get the first element on the right  that is larger than itself.</li>
<li>In the <code>nums2</code> traversal progress, when the current element is larger than the top element of the stack. We should determine if the top element of the stack has appeared in the <code>nums1</code>. If it appears, record the result.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 57 | 647. Palindromic Substrings | 516. Longest Palindromic Subsequence]]></title>
        <id>https://wuhumontana.github.io/post/day-57-or-647-palindromic-substrings-or-516-longest-palindromic-subsequence/</id>
        <link href="https://wuhumontana.github.io/post/day-57-or-647-palindromic-substrings-or-516-longest-palindromic-subsequence/">
        </link>
        <updated>2023-08-16T14:59:12.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132108800">Day 55 | 392. Is Subsequence | 115. Distinct Subsequences</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132114441">Day 56 | 583. Delete Operation for Two Strings | 72. Edit Distance</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#647-palindromic-substrings">647. Palindromic Substrings</a></li>
<li><a href="#516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="647-palindromic-substrings">647. Palindromic Substrings</h1>
<p><a href="https://leetcode.com/problems/palindromic-substrings/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int countSubstrings(String s) {
        char[] charS = s.toCharArray();
        int len = s.length();
        boolean[][] dp = new boolean[len][len];
        int result = 0;
        for(int i = len-1; i &gt;= 0; i--){
            for(int j = i; j &lt; len; j++){
                if(charS[i] == charS[j]){
                    if(j-i &lt;= 1){               // case 1,2
                        dp[i][j] = true;
                        result++;
                    }else if(dp[i+1][j-1]){     // case 3
                        dp[i][j] = true;
                        result++;
                    }
                }
            }
        }
        return result;
    }
}
</code></pre>
<ul>
<li><code>dp[i][j]</code>: whether a substring in the range <code>[i, j]</code> is a palindrome substring.</li>
<li><strong>Recursive Formula</strong>
<ul>
<li>If <code>s[i]</code> is different with <code>s[j]</code>, <code>dp[i][j]</code> must be <code>false</code>.</li>
<li>If <code>s[i]</code> is the same as <code>s[j]</code>, there are three cases as follows:
<ul>
<li>Same index like <code>i == j</code>, <code>s[i]</code> and <code>s[j]</code> are the same character</li>
<li>The difference between <code>i</code> and <code>j</code> is <code>1</code>, like <code>aa</code>. It is also a palindromic.</li>
<li>The difference between <code>i</code> and <code>j</code> is greater than <code>1</code>, like <code>cabac</code>. At this time, <code>s[i]</code> and <code>s[j]</code> are already the same. Whether <code>dp[i, j]</code> is palindromic depends on whether <code>dp[i+1, j-1]</code> is palindromic.</li>
</ul>
</li>
</ul>
</li>
<li>All elements in the array should be initialized to <code>false</code>.</li>
<li><strong>Traversal Order</strong>: According to the <code>case 3</code> of recursive formula, <code>dp[i][j]</code> is derived from <code>dp[i+1][j-1]</code>. So the traversal order must be <code>bottom to top</code>, <code>left to right</code>.</li>
</ul>
<hr>
<h1 id="516-longest-palindromic-subsequence">516. Longest Palindromic Subsequence</h1>
<p><a href="https://leetcode.com/problems/longest-palindromic-subsequence/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int longestPalindromeSubseq(String s) {  
        char[] charS = s.toCharArray();
        int[][] dp = new int[charS.length][charS.length];
        for(int i = 0; i &lt; charS.length; i++) dp[i][i] = 1;

        for(int i = charS.length-1; i &gt;= 0; i--){
            for(int j = i+1; j &lt; charS.length; j    ++){
                if(charS[i] == charS[j])
                    dp[i][j] = dp[i+1][j-1] + 2;
                else
                    dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1]);
            }
        }
        return dp[0][charS.length-1];
    }
}
</code></pre>
<ul>
<li>The palindromic substring is continuous, palindromic subsequence is not continuous.</li>
<li><code>dp[i][j]</code>: the length of the longest palindrome subsequence in the range <code>[i, j]</code>.</li>
<li><strong>Recursive Formula</strong>
<ul>
<li>If <code>s[i]</code> is the same as <code>s[j]</code>
<ul>
<li><code>dp[i][j] = dp[i+1][j-1] + 2</code></li>
</ul>
</li>
<li>If <code>s[i]</code> is different with <code>s[j]</code>
<ul>
<li>The length of palindromic subsequence adding <code>s[i]</code> is <code>dp[i][j-1]</code></li>
<li>The length of palindromic subsequence adding <code>s[j]</code> is <code>dp[i+1][j]</code></li>
<li>Choose the larger one: <code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Array Initialization</strong>
<ul>
<li>According to the <code>dp[i][j] = dp[i+1][j-1] + 2</code>, the recursive formula won't be able to calculate the <code>dp[i][j]</code> when <code>i</code> is the same as <code>j</code>.</li>
<li>So <code>dp[i][j]</code>(when <code>i == j</code>) must be initialized to <code>1</code>.</li>
</ul>
</li>
<li><strong>Traversal Order</strong>
<ul>
<li><code>dp[i][j]</code> is derived from <code>dp[i + 1][j - 1]</code>Ôºå<code>dp[i + 1][j]</code> and <code>dp[i][j - 1]</code>.</li>
<li>So we must traversal order must be <code>bottom to top</code>, <code>left to right</code>.</li>
<li>Since <code>dp[i][j]</code> has already been initialized to <code>1</code> when <code>i</code> is the same as <code>j</code>. We must start from <code>i+1</code> to traverse <code>j</code>.</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 56 | 583. Delete Operation for Two Strings | 72. Edit Distance]]></title>
        <id>https://wuhumontana.github.io/post/day-56-or-583-delete-operation-for-two-strings-or-72-edit-distance/</id>
        <link href="https://wuhumontana.github.io/post/day-56-or-583-delete-operation-for-two-strings-or-72-edit-distance/">
        </link>
        <updated>2023-08-16T14:58:56.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132108800">Day 55 | 392. Is Subsequence | 115. Distinct Subsequences</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#583-delete-operation-for-two-strings">583. Delete Operation for Two Strings</a></li>
<li><a href="#72-edit-distance">72. Edit Distance</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="583-delete-operation-for-two-strings">583. Delete Operation for Two Strings</h1>
<p><a href="https://leetcode.com/problems/delete-operation-for-two-strings/">Question Link</a></p>
<p><strong>Solution 1</strong></p>
<pre><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        char[] char1 = word1.toCharArray();
        char[] char2 = word2.toCharArray();
        int[][] dp = new int[char1.length+1][char2.length+1];
        int len = 0; // length of longest common subsequence
        for(int i = 1; i &lt;= char1.length; i++){
            for(int j = 1; j &lt;= char2.length; j++){
                if(char1[i-1] == char2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                len = Math.max(len, dp[i][j]);
            }
        }
        return char1.length + char2.length - len*2;
    }
}
</code></pre>
<ul>
<li>This solution stores the length of longest common subsequence on the dp array.</li>
<li>We could calculate <code>the length of longest common subsequence</code> first. Then the minimum number of steps is as follows:
<ul>
<li><code>word1.length() + word2.length() - len * 2</code></li>
</ul>
</li>
</ul>
<p><strong>Solution 2</strong></p>
<pre><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        char[] char1 = word1.toCharArray();
        char[] char2 = word2.toCharArray();
        int[][] dp = new int[char1.length+1][char2.length+1];
        for(int i = 0; i &lt;= char1.length; i++) dp[i][0] = i;
        for(int j = 0; j &lt;= char2.length; j++) dp[0][j] = j;
        
        for(int i = 1; i &lt;= char1.length; i++){
            for(int j = 1; j &lt;= char2.length; j++){
                if(char1[i-1] == char2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = Math.min(dp[i-1][j] + 1, dp[i][j-1] + 1);
            }
        }
        return dp[char1.length][char2.length];
    }
}
</code></pre>
<ul>
<li>This solution stores <code>the number of character that need to delete</code> on the dp array.</li>
<li><code>dp[i][j]</code>: The minimum number of delete operations required to make word1 ends with <code>i-1</code> and word2 ends with <code>j-1</code> the same.</li>
<li><strong>Recursive Formula</strong>
<ul>
<li>When <code>word1[i-1]</code> is the same as <code>word2[j-1]</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j-1]</code></li>
</ul>
</li>
<li>When <code>word1[i-1]</code> is different from <code>word2[j-1]</code>:
<ul>
<li>Delete <code>word1[i-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i-1][j] + 1</code></li>
<li>Delete <code>word2[j-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i][j-1] + 1</code></li>
<li>Delete <code>word1[i-1]</code> and <code>word2[j-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i-1][j-1] + 2</code>. We do not consider this case, cause <code>dp[i][j-1]</code> already disregarded <code>word2[j - 1]</code>. So when we delete <code>word1[i-1]</code>, we can achieve the effect of deleting both elements. That is <code>dp[i][j-1] + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Array Initialization</strong>
<ul>
<li><code>dp[i][0] = i</code>, cause any <code>word1</code> have to delete <code>i</code> elements to be a empty string.</li>
<li><code>dp[0][j] = j</code>, cause any <code>word2</code> have to delete <code>j</code> elements to be a empty string.</li>
</ul>
</li>
</ul>
<h1 id="72-edit-distance">72. Edit Distance</h1>
<p><a href="https://leetcode.com/problems/edit-distance/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int minDistance(String word1, String word2) {
        char[] char1 = word1.toCharArray();
        char[] char2 = word2.toCharArray();
        int[][] dp = new int[char1.length + 1][char2.length + 1];

        for(int i = 1 ; i &lt;= char1.length; i++) dp[i][0] = i;
        for(int j = 1; j &lt;= char2.length; j++) dp[0][j] = j;

        for(int i = 1 ; i &lt;= char1.length; i++){
            for(int j = 1; j &lt;= char2.length; j++){
                if(char1[i-1] == char2[j-1])
                    dp[i][j] = dp[i-1][j-1];
                else
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
            }
        }
        return dp[char1.length][char2.length];
    }
}
</code></pre>
<ul>
<li><code>dp[i][j]</code>: The minimum number of operations required to convert <code>word1</code> ends with <code>i-1</code> to <code>word2</code> ends with <code>j-1</code></li>
<li><strong>Recursive Formula</strong>
<ul>
<li>When <code>word1[i-1]</code> is the same as <code>word2[j-1]</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j-1]</code></li>
</ul>
</li>
<li>When <code>word1[i-1]</code> is different from <code>word2[j-1]</code>:
<ul>
<li>Delete/Insert<code>word1[i-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i-1][j] + 1</code>.</li>
<li>Delete/Insert <code>word2[j-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i][j-1] + 1</code>.</li>
<li>Replace <code>word1[i-1]</code> with <code>word2[j-1]</code>, minimum number of operations: <code>dp[i][j] = dp[i-1][j-1] + 1</code>.</li>
<li>Chose the minimum one: <code>dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Array Initialization</strong>
<ul>
<li><code>dp[i][0] = i</code>, cause any <code>word1</code> have to delete <code>i</code> elements to be an empty string or <code>word2</code> has to insert <code>i</code> elements to be the same as <code>word1</code></li>
<li><code>dp[0][j] = j</code>, cause any <code>word2</code> have to delete <code>j</code> elements to be an empty string or <code>word1</code> has to insert <code>j</code> elements to be the same as <code>word2</code></li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 55 | 392. Is Subsequence | 115. Distinct Subsequences]]></title>
        <id>https://wuhumontana.github.io/post/day-55-or-392-is-subsequence-or-115-distinct-subsequences/</id>
        <link href="https://wuhumontana.github.io/post/day-55-or-392-is-subsequence-or-115-distinct-subsequences/">
        </link>
        <updated>2023-08-16T14:58:37.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132080167">Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#392-is-subsequence">392. Is Subsequence</a></li>
<li><a href="#115-distinct-subsequences">115. Distinct Subsequences</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="392-is-subsequence">392. Is Subsequence</h1>
<p><a href="https://leetcode.com/problems/is-subsequence/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public boolean isSubsequence(String s, String t) {
        char[] charS = s.toCharArray();
        char[] charT = t.toCharArray();
        int[][] dp = new int[charS.length + 1][charT.length + 1];
        int result = 0;
        for(int i = 1; i &lt;= charS.length; i++){
            for(int j = 1; j &lt;= charT.length; j++){
                if(charS[i-1] == charT[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = dp[i][j-1];

                result = Math.max(dp[i][j], result);
            }
        }
        return result == charS.length;
    }
}
</code></pre>
<ul>
<li>The most significant difference with <code>1143. Longest Common Subsequence</code> is the <code>s</code> is the subsequence, so we only delete elements belong to <code>t</code>.</li>
</ul>
<hr>
<h1 id="115-distinct-subsequences">115. Distinct Subsequences</h1>
<p><a href="https://leetcode.com/problems/distinct-subsequences/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int numDistinct(String s, String t) {
        char[] charS = s.toCharArray();
        char[] charT = t.toCharArray();
        int[][] dp = new int[charS.length + 1][charT.length + 1];
        dp[0][0] = 1;
        for(int i = 1; i &lt;= charS.length; i++) dp[i][0] = 1;
        for(int j = 1; j &lt;= charT.length; j++) dp[0][j] = 0;

        for(int i = 1; i &lt;= charS.length; i++){
            for(int j = 1; j&lt;= charT.length; j++){
                if(charS[i-1] == charT[j-1])
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[charS.length][charT.length];
    }
}
</code></pre>
<ul>
<li><code>dp[i][j]</code> the number of distinct subsequences of <code>s</code> ends with <code>i-1</code> which equals <code>t</code> ends with <code>j-1</code>.</li>
<li><strong>Recursive Formula</strong>
<ul>
<li>When <code>s[i-1]</code> is different from <code>t[j-1]</code>, don't use the last element of <code>s</code> to match <code>t</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j]</code></li>
</ul>
</li>
<li>When <code>s[i-1]</code> is the same as <code>t[j-1]</code>, use and don't use the last element of <code>s</code> to match <code>t</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>Array Initialization</strong>
<ul>
<li><code>dp[0][0] = 1</code>, cause the subsequence of the empty array only could be an empty array.</li>
<li><code>dp[i][0] = 1</code>, cause any string only has one empty subsequence.</li>
<li><code>dp[0][j] = 0</code>, cause an empty string doesn't have any subsequences of length greater than 0.</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 53 | 1143. Longest Common Subsequence | 1035. Uncrossed Lines | 53. Maximum Subarray]]></title>
        <id>https://wuhumontana.github.io/post/day-53-or-1143-longest-common-subsequence-or-1035-uncrossed-lines-or-53-maximum-subarray/</id>
        <link href="https://wuhumontana.github.io/post/day-53-or-1143-longest-common-subsequence-or-1035-uncrossed-lines-or-53-maximum-subarray/">
        </link>
        <updated>2023-08-16T14:58:10.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132051515">Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#1143-longest-common-subsequence">1143. Longest Common Subsequence</a></li>
<li><a href="#1035-uncrossed-lines">1035. Uncrossed Lines</a></li>
<li><a href="#53-maximum-subarray">53. Maximum Subarray</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="1143-longest-common-subsequence">1143. Longest Common Subsequence</h1>
<p><a href="https://leetcode.com/problems/longest-common-subsequence/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] char1 = text1.toCharArray();
        char[] char2 = text2.toCharArray();
        int[][] dp = new int[text1.length() + 1][text2.length() + 1];
        for(int i = 1; i &lt;= char1.length; i++){
            for(int j = 1; j &lt;= char2.length; j++){
                if(char1[i-1]==char2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
            }
        }
        return dp[char1.length][char2.length];
    }
} 	

</code></pre>
<ul>
<li><code>dp[i][j]</code>: The longest common subsequence of <code>text1</code> whose length is <code>[0, i-1]</code> and <code>text2</code> whose length is <code>[0, j-1]</code>.</li>
<li><strong>Recursive Formula</strong>
<ul>
<li><code>text1[i-1]</code> is the same as the <code>text[j-1]</code>
<ul>
<li><code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
</ul>
</li>
<li><code>text[i-1]</code> is not the same as the <code>text[j-1]</code>
<ul>
<li><code>Math.max(dp[i-1][j], dp[i][j-1])</code></li>
</ul>
</li>
</ul>
</li>
<li>The longest common subsequence of empty strings is <code>0</code>, so <code>dp[i][0]</code> and <code>dp[0][j]</code> should be initialized to <code>0</code></li>
</ul>
<h1 id="1035-uncrossed-lines">1035. Uncrossed Lines</h1>
<p><a href="https://leetcode.com/problems/uncrossed-lines/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int result = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];
        for(int i = 1; i &lt;= nums1.length; i++){
            for(int j = 1; j &lt;= nums2.length; j++){
                if(nums1[i-1] == nums2[j-1])
                    dp[i][j] = dp[i-1][j-1] + 1;
                else
                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
                result = Math.max(dp[i][j], result);
            }
        }
        return result;
    }
}
</code></pre>
<ul>
<li>In this question, the maximum number of connecting lines is same like <code>1143. Longest Common Subsequence</code>.</li>
</ul>
<h1 id="53-maximum-subarray">53. Maximum Subarray</h1>
<p><a href="https://leetcode.com/problems/maximum-subarray/description/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int maxSubArray(int[] nums) {
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        int sum = nums[0];
        for(int i = 1; i &lt; nums.length; i++){
            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);
            sum = Math.max(sum, dp[i]);
        }
        return sum;
    }
}
</code></pre>
<ul>
<li><code>dp[i]</code>: The largest sum of the subarray(include <code>nums[i]</code>) of <code>nums</code></li>
<li><strong>Recursive Formula</strong>
<ul>
<li>1„ÄÅAdd <code>nums[i]</code> to the previous sum</li>
<li>2„ÄÅCalculate sum from <code>nums[i]</code></li>
<li><code>dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);</code></li>
</ul>
</li>
<li>According to the recursive formula, <code>dp[i]</code> depends on <code>dp[i-1]</code>. So <code>dp[0]</code> should be initialized to <code>nums[0]</code>.</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 52 | 300. Longest Increasing Subsequence | 674. Longest Continuous Increasing Subsequence | 718. Maximum Length of Repeated Subarray]]></title>
        <id>https://wuhumontana.github.io/post/day-52-or-300-longest-increasing-subsequence-or-674-longest-continuous-increasing-subsequence-or-718-maximum-length-of-repeated-subarray/</id>
        <link href="https://wuhumontana.github.io/post/day-52-or-300-longest-increasing-subsequence-or-674-longest-continuous-increasing-subsequence-or-718-maximum-length-of-repeated-subarray/">
        </link>
        <updated>2023-08-16T14:57:32.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132045089">Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#300-longest-increasing-subsequence">300. Longest Increasing Subsequence</a></li>
<li><a href="#674-longest-continuous-increasing-subsequence">674. Longest Continuous Increasing Subsequence</a></li>
<li><a href="#718-maximum-length-of-repeated-subarray">718. Maximum Length of Repeated Subarray</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="300-longest-increasing-subsequence">300. Longest Increasing Subsequence</h1>
<p><a href="https://leetcode.com/problems/longest-increasing-subsequence/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 1;
        for(int i = 1; i &lt; nums.length; i++){
            for(int j = 0; j &lt; i; j++)
                if(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1);
            // Choose the longest one
            if(dp[i] &gt; res)
                res = dp[i];
        }
        return res;
    }
}
</code></pre>
<ul>
<li><code>dp[i]</code>: The length of the longest strictly increasing subsequence ending in<code>nums[i]</code> that includes <code>i</code> and before <code>i</code>.</li>
<li><strong>Recursive Formula</strong>Ôºö<code>if(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i], dp[j] + 1)</code>;</li>
<li>For each <code>i</code>, the initial value of <code>dp[i]</code> is at least <code>1</code></li>
<li>Traversal order is <code>from front to back</code></li>
</ul>
<h1 id="674-longest-continuous-increasing-subsequence">674. Longest Continuous Increasing Subsequence</h1>
<p><a href="https://leetcode.com/problems/longest-continuous-increasing-subsequence/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 1; 
        for(int i = 1; i &lt; nums.length; i++){
            if(nums[i] &gt; nums[i-1])
                dp[i] = dp[i-1] + 1; 
            
            res = Math.max(dp[i], res);
        }
        return res;
    }
}
</code></pre>
<ul>
<li><code>dp[i]</code>: The length of the longest continuous increasing subsequence ending in <code>nums[i]</code>.</li>
<li>If <code>nums[i] &gt; nums[i-1]</code>, the length of the longest continuous increasing subsequence ending in <code>nums[i]</code> must be equal to the length of the longest continuous increasing subsequence ending in <code>nums[i-1]</code> + <code>1</code></li>
</ul>
<h1 id="718-maximum-length-of-repeated-subarray">718. Maximum Length of Repeated Subarray</h1>
<p><a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int result = 0;
        int[][] dp = new int[nums1.length + 1][nums2.length + 1];

        for(int i = 1; i &lt; nums1.length + 1; i++){
            for(int j = 1; j &lt; nums2.length + 1; j++){
                if(nums1[i-1] == nums2[j-1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    result = Math.max(result, dp[i][j]);
                }
            }
        }
        return result;
    }
}
</code></pre>
<ul>
<li><code>dp[i][j]</code>: The maximum length of repeated subarray of <code>nums1</code> ends with <code>[i-1]</code> and <code>nums2</code> ends with <code>[j-1]</code>.</li>
<li>According to to the definition of <code>dp[i][j]</code>, it can only be deduced from <code>dp[i-1][j-1]</code>. So when <code>nums1[i - 1]</code> and <code>nums2[j - 1]</code> are equal, the recursion formula is as follows:
<ul>
<li><code>dp[i][j] = dp[i-1][j-1] + 1</code></li>
<li>According to the recursion formula, we should start from <code>1</code> when traversing <code>i</code> and <code>j</code>.</li>
</ul>
</li>
<li><code>dp[i][0]</code> and <code>dp[0][j]</code> both are actually meaningless. But for the convenience of recursive formula, we should initialize it to <code>0</code>.<br>
<img src="https://img-blog.csdnimg.cn/img_convert/d22d6f37452f40f161cd595981f79f48.jpeg#pic_center" alt="Âú®ËøôÈáåÊèíÂÖ•ÂõæÁâáÊèèËø∞" loading="lazy"></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Day 51 | 309. Best Time to Buy and Sell Stock with Cooldown | 714. with Transaction Fee]]></title>
        <id>https://wuhumontana.github.io/post/day-51-or-309-best-time-to-buy-and-sell-stock-with-cooldown-or-714-with-transaction-fee/</id>
        <link href="https://wuhumontana.github.io/post/day-51-or-309-best-time-to-buy-and-sell-stock-with-cooldown-or-714-with-transaction-fee/">
        </link>
        <updated>2023-08-16T14:57:03.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/kyle313606922/article/details/128260518">Day 1 | 704. Binary Search | 27. Remove Element | 35. Search Insert Position | 34. First and Last Position of Element in Sorted Array</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128272450">Day 2 | 977. Squares of a Sorted Array | 209. Minimum Size Subarray Sum | 59. Spiral Matrix II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128281122">Day 3 | 203. Remove Linked List Elements | 707. Design Linked List | 206. Reverse Linked List</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128295618">Day 4 | 24. Swap Nodes in Pairs| 19. Remove Nth Node From End of List| 160.Intersection of Two Lists</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128310593">Day 6 | 242. Valid Anagram | 349. Intersection of Two Arrays | 202. Happy Numbe | 1. Two Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128324032">Day 7 | 454. 4Sum II | 383. Ransom Note | 15. 3Sum | 18. 4Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128325957">Day 8 | 344. Reverse String | 541. Reverse String II | ÊõøÊç¢Á©∫Ê†º | 151.Reverse Words in a String | Â∑¶ÊóãËΩ¨Â≠óÁ¨¶‰∏≤</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128337737">Day 9 | 28. Find the Index of the First Occurrence in a String | 459. Repeated Substring Pattern</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128358488">Day 10 | 232. Implement Queue using Stacks | 225. Implement Stack using Queue</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128359564">Day 11 | 20. Valid Parentheses | 1047. Remove All Adjacent Duplicates In String | 150. Evaluate RPN</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128382265">Day 13 | 239. Sliding Window Maximum | 347. Top K Frequent Elements</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128392214">Day 14 | 144.Binary Tree Preorder Traversal | 94.Binary Tree Inorder Traversal| 145.Binary Tree Postorder Traversal</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128405092">Day 15 | 102. Binary Tree Level Order Traversal | 226. Invert Binary Tree | 101. Symmetric Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 16 | 104.MaximumDepth of BinaryTree| 111.MinimumDepth of BinaryTree| 222.CountComplete TreeNodes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128415322">Day 17 | 110. Balanced Binary Tree | 257. Binary Tree Paths | 404. Sum of Left Leaves</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128451752">Day 18 | 513. Find Bottom Left Tree Value | 112. Path Sum | 105&amp;106. Construct Binary Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128466708">Day 20 | 654. Maximum Binary Tree | 617. Merge Two Binary Trees | 700.Search in a Binary Search Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128477578">Day 21 | 530. Minimum Absolute Difference in BST | 501. Find Mode in Binary Search Tree | 236. Lowes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128490148">Day 22 | 235. Lowest Common Ancestor of a BST | 701. Insert into a BST | 450. Delete Node in a BST</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128542480">Day 23 | 669. Trim a BST | 108. Convert Sorted Array to BST | 538. Convert BST to Greater Tree</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128572676">Day 24 | 77. Combinations</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128588207">Day 25 | 216. Combination Sum III | 17. Letter Combinations of a Phone Number</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128597793">Day 27 | 39. Combination Sum | 40. Combination Sum II | 131. Palindrome Partitioning</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128608537">Day 28 | 93. Restore IP Addresses | 78. Subsets | 90. Subsets II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128623556">Day 29 | 491. Non-decreasing Subsequences | 46. Permutations | 47. Permutations II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128638800">Day 30 | 332. Reconstruct Itinerary | 51. N-Queens | 37. Sudoku Solver</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128691410">Day 31 | 455. Assign Cookies | 376. Wiggle Subsequence | 53. Maximum Subarray</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128692538">Day 32 | 122. Best Time to Buy and Sell Stock II | 55. Jump Game | 45. Jump Game II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128702162">Day 34 | 1005. Maximize Sum Of Array After K Negations | 134. Gas Station | 135. Candy</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128710612">Day 35 | 860. Lemonade Change | 406. Queue Reconstruction by Height | 452. Minimum Number of Arrows</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128722599">Day 36 | 435. Non-overlapping Intervals | 763. Partition Labels | 56. Merge Intervals</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128733183">Day 37 | 738. Monotone Increasing Digits | 714. Best Time to Buy and Sell Stock | 968. BT Camera</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128740765">Day 38 | 509. Fibonacci Number | 70. Climbing Stairs | 746. Min Cost Climbing Stairs</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128745450">Day 39 | 62. Unique Paths | 63. Unique Paths II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/128798243">Day 41 | 343. Integer Break | 96. Unique Binary Search Trees</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/130127811">Day 42 | 0-1 Backpack Basic TheoryÔºà‰∏ÄÔºâ| 0-1 Backpack Basic TheoryÔºà‰∫åÔºâ| 416. Partition Equal Subset Sum</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131152206">Day 43 | 1049. Last Stone Weight II | 494. Target Sum | 474. Ones and Zeroes</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131343344">Day 44 | Full Backpack Basic Theory | 518. Coin Change II | 377. Combination Sum IV</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131812493">Day 45 | 70. Climbing Stairs | 322. Coin Change | 279. Perfect Squares</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131866549">Day 46 | 139. Word Break | Backpack Question Summary</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131898436">Day 48 | 198. House Robber | 213. House Robber II | 337. House Robber III</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/131936265">Day 49 | 121. Best Time to Buy and Sell Stock I | 122. Best Time to Buy and Sell Stock II</a><br>
<a href="https://blog.csdn.net/kyle313606922/article/details/132041808">Day 50 | 123. Best Time to Buy and Sell Stock III | 188. Best Time to Buy and Sell Stock IV</a></p>
<p><ul class="markdownIt-TOC">
<li><a href="#309-best-time-to-buy-and-sell-stock-with-cooldown">309. Best Time to Buy and Sell Stock with Cooldown</a></li>
<li><a href="#714-best-time-to-buy-and-sell-stock-with-transaction-fee">714. Best Time to Buy and Sell Stock with Transaction Fee</a></li>
</ul>
(Directory)</p>
<hr>
<h1 id="309-best-time-to-buy-and-sell-stock-with-cooldown">309. Best Time to Buy and Sell Stock with Cooldown</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices) {
        int[][] dp = new int[prices.length][4];
        dp[0][0] = -prices[0];

        for(int i = 1; i &lt; prices.length; i++){
            // Holding the stock
            dp[i][0] = Math.max(dp[i-1][0], Math.max(dp[i-1][1], dp[i-1][3]) - prices[i]);
            // Keep the state of doesn't hold the stock
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][3]);
            // Selling the stock
            dp[i][2] = dp[i-1][0] + prices[i];
            // Cooldown
            dp[i][3] = dp[i-1][2];
        }
        return Math.max(dp[prices.length-1][2], Math.max(dp[prices.length-1][1], dp[prices.length-1][3]));
    }
}
</code></pre>
<ul>
<li>In this question, there are <code>4</code> states are as follows:
<ul>
<li>State 1 <code>dp[i][0]</code>: Holding the stock.
<ul>
<li>Previous day already held the stockÔºö<code>dp[i][0] = dp[i-1][0]</code></li>
<li>Buy the stock today. The day before is in Cooldown: <code>dp[i][0] = dp[i-1][3] - prices[i]</code></li>
<li>Buy the stock today. The day before doesn't hold the stock: <code>dp[i][0] = dp[i-1][1] - prices[i]</code></li>
</ul>
</li>
<li>State 2 <code>dp[i][1]</code>: Keep the state of doesn't hold the stock.
<ul>
<li>The previous day also doesn't hold the stock: <code>dp[i][1] = dp[i-1][1]</code></li>
<li>The previous day is in Cooldown: <code>dp[i][1] = dp[i-1][3]</code></li>
</ul>
</li>
<li>State 3 <code>dp[i][2]</code>: Selling the stock today.
<ul>
<li>The previous day must be holding the stock: <code>dp[i][2] = dp[i-1][0] + prices[i]</code></li>
</ul>
</li>
<li>State 4 <code>dp[i][3]</code>: Cooldown.
<ul>
<li>The stock must have been sold the day before: <code>dp[i][3] = dp[i-1][2]</code></li>
</ul>
</li>
</ul>
</li>
<li>The result is the maximum value of states <code>2</code>, <code>3</code>, <code>4</code>.</li>
</ul>
<h1 id="714-best-time-to-buy-and-sell-stock-with-transaction-fee">714. Best Time to Buy and Sell Stock with Transaction Fee</h1>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">Question Link</a></p>
<pre><code class="language-java">class Solution {
    public int maxProfit(int[] prices, int fee) {
        int[][] dp = new int[prices.length][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i &lt; prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee);
            dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[prices.length - 1][0];
    }
}
</code></pre>
<ul>
<li>This question is similar like the <code>122. Best Time to Buy and Sell Stock II</code>.</li>
<li>The most significant difference is we should minus the <code>fee</code> when selling the stock.</li>
</ul>
]]></content>
    </entry>
</feed>